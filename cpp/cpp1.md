# Cpp 考前复习

## I. 计算机编码

主要类型有三种.

+ **原码**: 最高位是符号位, 其余各位表示数值.
+ **反码**: 正数与原码相同, 负数将**符号位以外**的0与1互换.
+ **<font color="Red">补码</font>**: 整数部分与原码相同, 负数位反码+1. 例如:
  - 1: 1000 0001
  - -1: 1111 1111

*注*: 计算机编码中, 0 表示正数, 1 表示负数.

## II. 运算符

### 逻辑运算符

运算**优先级**:
- 1. `!`
- 2. 乘除
- 3. 加减
- 4. `&&`
- 5. `||`
- 6. 三目运算符 `? :`
- 7. 赋值 `=`

*注*: 逻辑运算符存在**副作用**.
- 对 `a && b` , a = 0 时不在进行b运算.
- 对 `a || b` , a != 0 时不在进行b运算.

### 位运算

- `~a` 表示对a对应的二进制数取反码.
- `a << n, a >> n` 分别表示左/右移n位.
- `a & b` 表示按位**与**, 均为1时取1.
- `a | b` 表示按位**或**, 存在1时取1.
- `a ^ b` 表示按位**异或**, **值不同**时取1.

## III. 变量

### 变量与其内存

- `bool, char` 1字节
- `short int` 2字节
- `int, long int, unsigned long int, float` 4字节
- `double, long double` 8字节

*注*: 区分 `sizeof()` 与 `strlen()` . 例如: 

```c++
char a[] = "abc\0def";
strlen(a); //=3, 只截取至'\0'前
sizeof(a); //=8, '\0'占1个字节, 且结尾自动添加'\0'
```

*注*: 还要区分 `sizeof()` 中的内容是数组还是**指针**. 接上例: 

```c++
char *ptr = a;
sizeof(ptr); //=4, ptr存储的是地址, 即一个无符号整型
```

### 变量类型转换

在多个类型的变量同时参与计算时, 均会向**精度更高**的变量类型转换. 例如:

```c++
//eg1
char ch = 'a';
cout << ch+1 << endl; //自动转换为int, 输出98
//eg2
int a = 2;
cout << a/2. << endl; //自动转换为double, 输出1.0
```

*注意!*

- 若将eg1中改为 `++ch` , 那么输出结果为 b , 这是因为 `++` 运算中不涉及整型数.
- eg2中 `sizeof(a/2.)` 结果为8, 因为系统将 `2.` 认为是 double 型.

## IV.枚举类型

枚举类型在编程中并不十分常见, 但在考试中几乎必考. 定义形如:

```c++
enum name {a, b, c};
```

*注*: a, b, c 是**枚举常量**, 必须是常变量的标识符, 如 `1` , `'a'` 均是非法定义. 

在定义时, 默认其值**从0开始**定义. 如果其中一个内容赋值, 则其后常量按顺序赋值. 例如:

```c++
enum var {a, b = 3, c, d};
// a=0, b=3, c=4, d=5
```

枚举变量之所以被称为**变量**, 是因为其值可改变, 但值只能在枚举常量中选择. 另外, 枚举变量与枚举常量均可以进行逻辑运算.

## V.变量存储类型

我们日常使用的变量为**自动变量**, 即 `auto int` , 一般省略前面的auto. (不进行初始化时, 赋随机值)

**静态变量**: **生命期**为整个程序, 但只有**块作用域**.

```c++
{
  static int n = 5;  //再次执行至此时, n仍为++后的值.
  n++;
}

```

- **只在第一次进行初始化**.
- 若不进行初始化, 默认**置0**.

**全局变量**: 具有全局生命期与作用域. 不进行初始化时, 默认**置0**. 被块变量覆盖时, 前面需加上单目运算符 `::` .

```c++
int a;  //自动赋值a=0
{
  int a = 1;
  cout << a << endl;  //输出1
  cout << ::a << endl; //输出0
}
```

## VI.函数的参数

- `void f(int a)` : 参数可以是变量, 常量, 常变量, 表达式.
- `void f(int &a)` : a是变量的别名, 参数必须是**变量**(含变量的表达式也不行).
- `void f(int *a)` : a是**指针**, 参数必须是指针(即某个**地址**). 例如: 

```c++
int a = 0;
f(&a);
int b[10] = {0};
f(b);  //这是因为, 数组直接表示了其地址.
```

*注*: 在这种情况下, 函数内部使用形参必须进行取内容操作, 即使用 `*a` .

**缺省参数**: 当实参为空时, 可以为其设定**默认值**. 例如:

```c++
inf f(int a = 1; b){...}
int main(){
  f(2);
  //这时, a被缺省, 实际调用的为函数f(1,2).
}
```

## VII.指针运算符

### 指针与常量

+ **指针常量**: 不可改变指向.

```c++
int n = 5;
int *const p = &n;
//此时, 可以通过p改变n的值, 但p不可以指向其他变量了.
```

+ **常量指针**: 不可改变值(亦称为**只读**指针).

```c++
char ch1, ch2;
char const *p = ch1;
ch1 = 'a';  //不可通过p改变ch1的值
p = ch2; //可以改变p的指向
```

这两者是非常容易混淆的. 我们需要记住 `const` 具有**左结合原则***, 即其左边的内容具有不变性.

*这个名字是我自己诌的.

### 指针与 `++`

区分下面的内容.

```c++
int arr[3] = {0,1,2};
int *p = arr;
```

// 此时, p指向arr[0]

```c++
/*---注:下面的分割线之间的内容互不影响---*/
/*-----1-----*/
cout << *p++;
```

这时, p已经进行了 `++` 操作, 指向数字1. 但**后置 `++` 只提取 `++` 前的内容**, 故显示的值为0.

```c++
/*-----2-----*/
cout << (*p)++;
```

这时, p指向的内容, 即 `arr[0]=0` 先被提取, 再对其值进行 `++` , 故显示的值为1.

```c++
/*-----3-----*/
cout << ++*p;
```

与2同理, 略.

```c++
/*-----4-----*/
cout << *++p;
```

这时, p先进行 `++` 操作, 指向了 `arr[1]=1` , 随后再进行取值操作, 显示的值为1.

<完>

回到[目录](index.html)

<u>Edit on VScode</u>
